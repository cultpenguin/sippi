<sect1 xml:id="sec_ex_tomography"><title>Cross hole tomography</title>
<para>
SIPPI includes the implemenation of multiple methods for computing the travel time delay between a set of sources and receivers. This allow SIPPI to work on for example cross hole tomographic forward and inverse problems.
</para>
<para>
In addition, a reference cross hole GPR data set is also avaialble, and will be used here to demonstrate the use of SIPPI to solve cross hole tomographic inversion in a probabilistic framework.
</para>
<para>
Please see <citation>HCLM13b</citation> for more details on the example of using SIPPI to sample the posterior for cross hole tomograohic inverse problems. See <citation>LHC10</citation> for more details on the data from Arrenæs.
</para>

<!-- ARRENÆS DATA -->
<sect2 xml:id="arrenaes_data"><title>Reference data set from Arrenæs</title>
<para>
A 2D/3D data set of recorded travel time data from a cross hole Georadar experiment is available in the 'data/crosshole' folder.
</para>
<para>
4 Boreholes were drilled, AM1, AM2, AM3, and AM4 at the locations shown below 
</para>
<figure><title>Location of boreholes AM1, AM2, AM3, and AM4 at Arrenæs.</title>
<mediaobject>
  <imageobject condition="web">
    <imagedata fileref="figures/sippi_arrenaes_3d_setup.png" width="35%" scalefit="1"/>
  </imageobject>
  <textobject><phrase></phrase></textobject>
</mediaobject>
</figure>

<para>
Traveltime data were collected between boreholes AM1 and AM3, and AM2 and AM4 respecitvely, in a depth interval betwee 1m and 12m. The traveltimes for each of the two 2D data sets are available in the AM13_data.mat and AM24_data.mat files. All the data have been combined in the 3D data set available in AM1234_data.mat.
</para>
<para>
All mat-files contains the following variable
<screen>
S --> [ndata,ndim] each row contains the position of the source
R --> [ndata,ndim] each row contains the position of the receiver
d_obs --> [ndata,1] each row contains the observed traveltime in milliseconds 
d_std --> [ndata,1] each row contains the standard deaviation of the uncertainty of the observed traveltime in milliseconds
</screen>
All data are also available as ASCII formatted EAS files in <filename>AM13_data.eas</filename>, <filename>AM24_data.eas</filename>, and <filename>AM1234_data.eas</filename>. 
</para>

<para>
The following 3 Figures show the ray coverage (using straight rays) for each of the AM13, AM24, and AM1234 data sets. The color of each ray indicates the average velocity along the ray computed using v_av = raylength/d_obs.
AM13 ray coverageAM24 ray coverageAM1234 ray coverage.
</para>
<figure><title>Ray coverage beetween wells left) AM1-AM3, middle) AM2-AM4, right) AM1-4.</title>
<mediaobject>
  <imageobject condition="web">
    <imagedata fileref="figures/arrenaes_raycoverage.png" width="75%" scalefit="1"/>
  </imageobject>
  <textobject><phrase></phrase></textobject>
</mediaobject>
</figure>


</sect2>

<!-- FORWARD MODEL -->
<sect2 xml:id="forward_traveltime"><title>Travel delay computation: The forward problem</title>
<para>
A number of different methods for solving the problem of computing the first arrival travel time of a seismic or electromagnetic wave traveling between a source in one borehole and a receiver in another borehole has been implemented in the m-file 'sippi_forward_traveltime'.
<screen>
[d,forward,prior,data]=sippi_forward_traveltime(m,forward,prior,data,id,im)
</screen>
In order to use this m-file to descrie the forward problem sepcify the 'forward_function' field in the <varname>forward</varname> structure using 
<screen>
forward.forward_function='sippi_forward_traveltime';
</screen>

</para>
<para>In order to use <filename>sippi_forward_traveltime</filename>, the location of the sources and receivers must be specified in the <varname>forward.S</varname> and <varname>forward.R</varname>. The number of columns reflect the number of data, and the number of rows reflect whether data are 2D (2 columns) or 3D (3 columns):
<screen>
forward.S %  [ndata,ndim]
forward.R %  [ndata,ndim]
</screen>
Using for example the data from Arrenæs, the forward geometry can be set up using 
<screen>
D=load('AM13_data.mat');
forward.sources=D.S;
forward.receivers=D.R;
</screen>
</para>

<para>In addition the method used to compute the travel times must also be given (see below).
</para>
<para>
In order to use the geometry from the AM13 reference data, and the Eikonal solution to the wave-equation, the <varname>forward</varname> structure can be defined using
<screen>
D=load('AM13_data.mat');
forward.forward_function='sippi_forward_traveltime';
forward.sources=D.S;
forward.receivers=D.R;
forward.type='eikonal';
</screen>
</para>


<!-- type=ray -->
<sect3><title>Ray type forward model (high frequency approximation)</title>
<para>
Ray type models are based on an assumption that the wave propagating between the source and the receiver has infinitely high frequency. Therefore the travel time delay is due to the velocity along a ray connecting the source and receiver.
</para>
<para>
The linear so-called straight ray approximation, which assumes that the travel time for a wave travelling between a source and a receiver is due to the travel time delay along a straight line connecting the source and receiver, can be chosen using
<screen>
forward.type='ray';
forward.linear=1;
</screen>
</para>
<para>
The corresponding so-called bended-ray approximation, where the travel time delay is due to the travel time delay along the fast ray path connecting a source and a receiver, can be chosen using
<screen>
forward.type='ray';
forward.linear=0;
</screen>
</para>
<para>
When sippi_forward_traveltime has been called once, the associated forward mapping operator is stored in 'forward.G' such the the forward problem can simply be solved by calling e.g. 'd{1}=forward.G*m{1}'
</para>
</sect3>



<!-- type=fat -->
<sect3><title>Fat Ray type forward model (finite frequency approximation)</title>
<para>
Fat type model assume that the wave propagating between the source and the receiver has finite high frequency. This means that the travel time is sensitive to an area around the raypath, typically defined using the 1st Fresnel zone.
</para>
<para>
A linear fat ray kernel can be chosen using
<screen>
forward.type='fat';
forward.linear=1;
forward.freq=0.1;
</screen>
and the corresponding non-linear fat kernel using
<screen>
bforward.type='fat';
forward.linear=0;
forward.freq=0.1;
</screen>
</para>
<para>
Note that the center frequency of the propagating wave must also be provided in the 'forward.freq' field. The smaller the frequency, the 'fatter' the ray kernel.
</para>
<para>
For 'fat' type forward models we rely on the method described by 
Jensen, J. M., Jacobsen, B. H., and Christensen-Dalsgaard, J. (2000). Sensitivity kernels for time-distance inversion. Solar Physics, 192(1), 231-239
</para>
</sect3>

<!-- type=born -->
<sect3><title>Born type forward model (finite frequency approximation)</title>
<para>
Using the Born approximation, considering only first order scattering, can be chosen using
<screen>
forward.type='born';
forward.linear=1;
forward.freq=0.1;
</screen>
</para>
<para>
For a velocity field with small spatial variability one can compute 'born' type kernels (using 'forward.linear=0', but as the spatial variability increases this is not possible.
</para>
<para>
For the 'born' type forward model we make use if the method described by 
Buursink, M. L., Johnson, T. C., Routh, P. S., and Knoll, M. D. (2008). Crosshole radar velocity tomography with finite‐frequency Fresnel volume sensitivities. Geophysical Journal International, 172(1), 1-17.
</para>
</sect3>

<!-- type=eikonal-->
<sect3><title>The eikonal equation (high frequency approximation)</title>
<para>
The eikonal solution to the wave-equation is a high frequency approximation, such as the one given above.
</para>
<para>
However, it is computationally more eficcient to solve the eikonal eqation directly, that to used the 'forward.type='ray';' type forward model.
</para>
<para> 
To coose the eikonal solver to compute travel times use
<screen>
forward.type='eikonal';
</screen>
</para>
<para>
The Accurate Fast Marching Matlab toolbox : http://www.mathworks.com/matlabcentral/fileexchange/24531-accurate-fast-marching is used to solve the Eikonal equation.</para>
</sect3>

</sect2>


<!-- INVERSION EXAMPLES -->
<sect2 xml:id="arrenaes_inversion"><title>Inversion of cross hole GPR data from Arrenaes data</title>
<para>
This section contains examples for setting up and runnning an cross hole tomographic inversion using SIPPI using the <link linkend="arrenaes_data">reference data from Arrenæs</link>, different types of a priroi and <link linkend="forward_traveltime">forward models</link>.
</para>
<para>
Example Matlab scripts fro the examples below, and more, are located in <link xlink:href="http://svn.code.sf.net/p/sippi/code/trunk/examples/case_tomography/">examples/case_tomography/</link>.
</para>


<sect3 xml:id="AM13_data"><title>Setting up the data structure</title>
<para>
Initially we load the travel time data obtained at Arrenæs (See Arrenæs Data for more information)
<screen>
D=load('AM13_data.mat');
</screen>
This allow us to setup a SIPPI data structure defining the observed data as well as the associated model of uncertainty
<screen>
%% SETUP DATA  
id=1;
data{id}.d_obs=D.d_obs;
data{id}.d_std=D.d_std;
data{id}.dt=0; % Mean modelization error
data{id}.Ct=1; % Covariance describing modelization error
</screen>
In the above example we define a Gaussian modelization error, N(dt,Ct). We do this because we will make use of a forward model, the eikonal solver, that we know will systematically provide faster travel times than can be obtained from the earth. In reality the wave travelling between bore holes never has infinitely high frequency as assumed by using the eikonal solver. The eikonal solver provides the fast travel time along a ray connecting the source and receiver. Therefore we introduce a modelization error, that will allow all the travel times to be biased with the same travel time.
</para>
</sect3>

<sect3 xml:id="AM13_forward"><title>Setting up the forward structure</title>
<para>
'sippi_forward_traveltime' require that the location of the sources an receivers are provided in 'forward' structure using the 'sources' and 'receivers' fieldnames.
<screen>
D=load('AM13_data.mat');
forward.sources=D.S;
forward.receivers=D.R;
forward.type='eikonal';
</screen>
Here the eikonal solution is chosen to solve the forward problem. See more detail about solving the forward problem related to cross hole first arrival travel time computation <link linkend="forward_traveltime">here</link>-
</para>
</sect3>


<!-- INVERSION EXAMPLES -->
<sect3 xml:id="AM13_gaussian"><title>2D, Gaussian prior</title>
<para>
In the following a simple 2D Gaussian a priori model is defined, and SIPPI is used to sample the correspondinng a posteriori distribution. (An example script is avalable at <link xlink:href="http://svn.code.sf.net/p/sippi/code/trunk/examples/case_tomography/sippi_AM13_metropolis_gaussian.m">examples/case_tomography/sippi_AM13_metropolis_gaussian.m</link>).
</para>

<para>
<screen>
%% SETUP PRIOR 
im=1;
prior{im}.type='FFTMA';
prior{im}.m0=0.145;
prior{im}.Va='.0003 Sph(6)';
prior{im}.x=[-1:.15:6];
prior{im}.y=[0:.15:13];
</screen>
</para>

<para>
<!--
  <programlisting><xi:include  href="../examples/prior_tests/prior_reals_snesim.m"  parse="text"/></programlisting>
-->
</para>

<para>
This is all the information needed to setup the forward problem. To actually solve the forward problem for a given model 'm', and compute the corresponding data, use e.g.
<screen>
% Compute the forward response related to the realization of the prior
% model generated above
[d,forward,prior,data]=sippi_forward(m,forward,prior,data);
% plot the forward response and compare it to the observed data
sippi_plot_data(d,data);
</screen>
As the both the 'data', 'prior', and 'forward' structure have been setup, we are ready to use SIPPI for inversion.
</para>



</sect3>


</sect2>




</sect1>
