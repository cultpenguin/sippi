<sect1 xml:id="sec_ex_tomography"><title>Cross hole tomography</title>
<para>
SIPPI includes a <link linkend="arrenaes_data">reference cross hole GPR data from Arrenaes</link> set is also avaialble, and will be used here to demonstrate the use of SIPPI to solve cross hole tomographic inversion in a probabilistic framework. 
</para>
<para>
SIPPI also includes the implemenation of multiple methods for <link linkend="forward_traveltime">computing the travel time delay between a set of sources and receivers</link>. This allows SIPPI to work on for example cross hole tomographic forward and inverse problems.
</para>

<para>
This section contains examples for setting up and runnning an cross hole tomographic inversion using SIPPI using the <link linkend="arrenaes_data">reference data from Arrenæs</link>, different types of a priroi and <link linkend="forward_traveltime">forward models</link>.
</para>
<para>
Example Matlab scripts for the examples below, and more, are located in <link xlink:href="http://svn.code.sf.net/p/sippi/code/trunk/examples/case_tomography/">examples/case_tomography/</link>.
</para>

<para>
Please see <citation>HCLM13b</citation> for more details on the example of using SIPPI to sample the posterior for cross hole tomograohic inverse problems. See <citation>LHC10</citation> for more details on the data from Arrenæs.
</para>

<!-- ARRENÆS DATA -->
<sect2 xml:id="arrenaes_data"><title>Reference data set from Arrenæs</title>
<para>
A 2D/3D data set of recorded travel time data from a cross hole Georadar experiment is available in the 'data/crosshole' folder.
</para>
<para>
4 Boreholes were drilled, AM1, AM2, AM3, and AM4 at the locations shown below 
</para>
<figure><title>Location of boreholes AM1, AM2, AM3, and AM4 at Arrenæs.</title>
<mediaobject>
  <imageobject condition="web">
    <imagedata fileref="figures/sippi_arrenaes_3d_setup.png" width="35%" scalefit="1"/>
  </imageobject>
  <textobject><phrase></phrase></textobject>
</mediaobject>
</figure>

<para>
Traveltime data were collected between boreholes AM1 and AM3, and AM2 and AM4 respecitvely, in a depth interval betwee 1m and 12m. The traveltimes for each of the two 2D data sets are available in the AM13_data.mat and AM24_data.mat files. All the data have been combined in the 3D data set available in AM1234_data.mat.
</para>
<para>
All mat-files contains the following variable
<screen>
S --> [ndata,ndim] each row contains the position of the source
R --> [ndata,ndim] each row contains the position of the receiver
d_obs --> [ndata,1] each row contains the observed traveltime in milliseconds 
d_std --> [ndata,1] each row contains the standard deaviation of the uncertainty of the observed traveltime in milliseconds
</screen>
All data are also available as ASCII formatted EAS files in <filename>AM13_data.eas</filename>, <filename>AM24_data.eas</filename>, and <filename>AM1234_data.eas</filename>. 
</para>

<para>
The following 3 Figures show the ray coverage (using straight rays) for each of the AM13, AM24, and AM1234 data sets. The color of each ray indicates the average velocity along the ray computed using v_av = raylength/d_obs.
AM13 ray coverageAM24 ray coverageAM1234 ray coverage.
</para>
<figure><title>Ray coverage beetween wells left) AM1-AM3, middle) AM2-AM4, right) AM1-4.</title>
<mediaobject>
  <imageobject condition="web">
    <imagedata fileref="figures/arrenaes_raycoverage.png" width="75%" scalefit="1"/>
  </imageobject>
  <textobject><phrase></phrase></textobject>
</mediaobject>
</figure>


</sect2>

<!-- FORWARD MODEL -->
<sect2 xml:id="forward_traveltime"><title>Travel delay computation: The forward problem</title>
<para>
A number of different methods for solving the problem of computing the first arrival travel time of a seismic or electromagnetic wave traveling between a source in one borehole and a receiver in another borehole has been implemented in the m-file 'sippi_forward_traveltime'.
<screen>
[d,forward,prior,data]=sippi_forward_traveltime(m,forward,prior,data,id,im)
</screen>
In order to use this m-file to descrie the forward problem sepcify the 'forward_function' field in the <varname>forward</varname> structure using 
<screen>
forward.forward_function='sippi_forward_traveltime';
</screen>

</para>
<para>In order to use <filename>sippi_forward_traveltime</filename>, the location of the sources and receivers must be specified in the <varname>forward.S</varname> and <varname>forward.R</varname>. The number of columns reflect the number of data, and the number of rows reflect whether data are 2D (2 columns) or 3D (3 columns):
<screen>
forward.S %  [ndata,ndim]
forward.R %  [ndata,ndim]
</screen>
Using for example the data from Arrenæs, the forward geometry can be set up using 
<screen>
D=load('AM13_data.mat');
forward.sources=D.S;
forward.receivers=D.R;
</screen>
</para>

<para>In addition the method used to compute the travel times must also be given (see below).
</para>
<para>
In order to use the geometry from the AM13 reference data, and the Eikonal solution to the wave-equation, the <varname>forward</varname> structure can be defined using
<screen>
D=load('AM13_data.mat');
forward.forward_function='sippi_forward_traveltime';
forward.sources=D.S;
forward.receivers=D.R;
forward.type='eikonal';
</screen>
</para>


<!-- type=ray -->
<sect3><title>Ray type forward model (high frequency approximation)</title>
<para>
Ray type models are based on an assumption that the wave propagating between the source and the receiver has infinitely high frequency. Therefore the travel time delay is due to the velocity along a ray connecting the source and receiver.
</para>
<para>
The linear so-called straight ray approximation, which assumes that the travel time for a wave travelling between a source and a receiver is due to the travel time delay along a straight line connecting the source and receiver, can be chosen using
<screen>
forward.type='ray';
forward.linear=1;
</screen>
</para>
<para>
The corresponding so-called bended-ray approximation, where the travel time delay is due to the travel time delay along the fast ray path connecting a source and a receiver, can be chosen using
<screen>
forward.type='ray';
forward.linear=0;
</screen>
</para>
<para>
When sippi_forward_traveltime has been called once, the associated forward mapping operator is stored in 'forward.G' such the the forward problem can simply be solved by calling e.g. 'd{1}=forward.G*m{1}'
</para>
</sect3>



<!-- type=fat -->
<sect3><title>Fat Ray type forward model (finite frequency approximation)</title>
<para>
Fat type model assume that the wave propagating between the source and the receiver has finite high frequency. This means that the travel time is sensitive to an area around the raypath, typically defined using the 1st Fresnel zone.
</para>
<para>
A linear fat ray kernel can be chosen using
<screen>
forward.type='fat';
forward.linear=1;
forward.freq=0.1;
</screen>
and the corresponding non-linear fat kernel using
<screen>
bforward.type='fat';
forward.linear=0;
forward.freq=0.1;
</screen>
</para>
<para>
Note that the center frequency of the propagating wave must also be provided in the 'forward.freq' field. The smaller the frequency, the 'fatter' the ray kernel.
</para>
<para>
For 'fat' type forward models we rely on the method described by 
Jensen, J. M., Jacobsen, B. H., and Christensen-Dalsgaard, J. (2000). Sensitivity kernels for time-distance inversion. Solar Physics, 192(1), 231-239
</para>
</sect3>

<!-- type=born -->
<sect3 xml:id="forward_traveltime_born"><title>Born type forward model (finite frequency approximation)</title>
<para>
Using the Born approximation, considering only first order scattering, can be chosen using
<screen>
forward.type='born';
forward.linear=1;
forward.freq=0.1;
</screen>
</para>
<para>
For a velocity field with small spatial variability one can compute 'born' type kernels (using 'forward.linear=0', but as the spatial variability increases this is not possible.
</para>
<para>
For the 'born' type forward model we make use if the method described by 
Buursink, M. L., Johnson, T. C., Routh, P. S., and Knoll, M. D. (2008). Crosshole radar velocity tomography with finite‐frequency Fresnel volume sensitivities. Geophysical Journal International, 172(1), 1-17.
</para>
</sect3>

<!-- type=eikonal-->
<sect3><title>The eikonal equation (high frequency approximation)</title>
<para>
The eikonal solution to the wave-equation is a high frequency approximation, such as the one given above.
</para>
<para>
However, it is computationally more eficcient to solve the eikonal eqation directly, that to used the 'forward.type='ray';' type forward model.
</para>
<para> 
To coose the eikonal solver to compute travel times use
<screen>
forward.type='eikonal';
</screen>
</para>
<para>
The Accurate Fast Marching Matlab toolbox : http://www.mathworks.com/matlabcentral/fileexchange/24531-accurate-fast-marching is used to solve the Eikonal equation.</para>
</sect3>

</sect2>


<!-- INVERSION EXAMPLES FROM ARRENAES -->
<sect2 xml:id="AM13_gaussian"><title>AM13 Gaussian: Inversion of cross hole GPR data from Arrenaes data with a Gaussian type a priori model</title>

<para>
In the following a simple 2D Gaussian a priori model is defined, and SIPPI is used to sample the corresponding a posteriori distribution. (An example script is avalable at <link xlink:href="http://svn.code.sf.net/p/sippi/code/trunk/examples/case_tomography/sippi_AM13_metropolis_gaussian.m">examples/case_tomography/sippi_AM13_metropolis_gaussian.m</link>).
</para>

<sect3 xml:id="AM13_data"><title>Setting up the data structure</title>
<para>
Initially we load the travel time data obtained at Arrenæs (See Arrenæs Data for more information)
<screen>
D=load('AM13_data.mat');
</screen>
This allow us to setup a SIPPI data structure defining the observed data as well as the associated model of uncertainty
<screen>
%% SETUP DATA  
id=1;
data{id}.d_obs=D.d_obs;
data{id}.d_std=D.d_std;
data{id}.dt=0; % Mean modelization error
data{id}.Ct=1; % Covariance describing modelization error
</screen>
In the above example we define a Gaussian modelization error, N(dt,Ct). We do this because we will make use of a forward model, the eikonal solver, that we know will systematically provide faster travel times than can be obtained from the earth. In reality the wave travelling between bore holes never has infinitely high frequency as assumed by using the eikonal solver. The eikonal solver provides the fast travel time along a ray connecting the source and receiver. Therefore we introduce a modelization error, that will allow all the travel times to be biased with the same travel time.
</para>
</sect3>

<sect3 xml:id="AM13_prior_gaussian"><title>Setting up the prior model</title>
<para>
The a priori model is defined using the <varname>prior</varname> data structure. Here a 2D Gaussian type a priori model in a 7x13 m grid (grid cell size .25m) using the <link linkend="prior_fftma">FFTMA</link> type a priori model. The a priori mean is 0.145 m/ns, and the covariance function a Spherical type covariance model with a range of 6m, and a sill(variance) of 0.0003 m^2/ns^2.
<screen>
%% SETUP PRIOR 
im=1;
prior{im}.type='FFTMA';
prior{im}.m0=0.145;
prior{im}.Va='.0003 Sph(6)';
prior{im}.x=[-1:.15:6];
prior{im}.y=[0:.15:13];
</screen>
One could make used of the <link linkend="prior_visim">VISIM</link> type priori model simply by substituting 'FFTMA' with 'VISIM' above.
</para>
</sect3>

<sect3 xml:id="AM13_forward"><title>Setting up the forward structure</title>
<para>
<link linkend="forward_traveltime">'sippi_forward_traveltime'</link> require that the location of the sources an receivers are provided in 'forward' structure using the 'sources' and 'receivers' fieldnames.
<screen>
D=load('AM13_data.mat');
forward.forward_function='sippi_forward_traveltime';
forward.sources=D.S;
forward.receivers=D.R;
forward.type='eikonal';
</screen>
Here the eikonal solution is chosen to solve the forward problem. See more detail about solving the forward problem related to cross hole first arrival travel time computation <link linkend="forward_traveltime">here</link>.
</para>
</sect3>

<sect3 xml:id="AM13_testing"><title>Testing the setup</title>
<para>
As the 
<varname>prior</varname>,
<varname>data</varname>, and 
<varname>forward</varname> have been defined, one can in principle initiate an inversion. However, it is advised to perform a few test before applying the inversion.
</para>
<para>

First, one should check that independant realization of the prior model resemble the a priori knowledge. A sample from the prior model can be generated and visualized calling <link linkend="sippi_plot_prior_sample">sippi_plot_prior_sample</link>:
<screen>
sippi_plot_prior_sample(prior);
</screen>
which provides the folliwing figure
<figure><title>AM13: One sample (15 realizations) of the prior (Gaussian) model.</title>
<mediaobject>
  <imageobject condition="web">
    <imagedata fileref="figures/AM13_prior_sample.png" width="50%" scalefit="1"/>
  </imageobject>
  <textobject><phrase></phrase></textobject>
</mediaobject>
</figure>

The one can check that the forward solver, and the computation of the likelihood wors as expected using
<screen>
% generate a realization from the prior
m=sippi_prior(prior);
% Compute the forward response related to the realization of the prior model generated above
[d]=sippi_forward(m,forward,prior,data);
% Compute the likelihood 
[logL,L,data]=sippi_likelihood(d,data);
% plot the forward response and compare it to the observed data
sippi_plot_data(d,data);
</screen>
which produce a figure similar to 
<figure><title>AM13: Data response from one realization of the prior.</title>
<mediaobject>
  <imageobject condition="web">
    <imagedata fileref="figures/AM13_data.png" width="50%" scalefit="1"/>
  </imageobject>
  <textobject><phrase></phrase></textobject>
</mediaobject>
</figure>
</para>

<!--
<para>
  <programlisting><xi:include  href="../examples/case_tomography/sippi_AM13_metropolis_gaussian.m"  parse="text"/></programlisting>
</para>
-->

</sect3>

<sect3 xml:id="AM13_metropolis"><title>Sampling the a posterior distribution using the extended Metropolis algorithm</title>
<para>
The <link linkend="sec_extendedmetropolis">extended Metropolis sampler</link> can now be run using <link linkend="sippi_metropolis">sippi_metropolis</link>.
<screen>
options=sippi_metropolis(data,prior,forward);
</screen>
In practice the user will have to set a few options, controlling the behaviour of the algorithm. In the following example the number of iterations is set to 500000; the current model is saved to disc for every 500 iterations; the log-likelihood and current model is shown for every 1000 iterations:
<screen>
options.mcmc.nite=500000; % optional, default:nite=30000
options.mcmc.i_sample=500; % optional, default:i_sample=500;
options.mcmc.i_plot=1000; % optional, default:i_plot=50;
options=sippi_metropolis(data,prior,forward,options);
</screen>
By default no <link linkend="sec_metropolis_annealing">annealing schedule</link> is used. By default the <link linkend="sec_controling_step_length">'step'-length</link> for sequential Gibbs sampling is adjusted (to obtain an averahe acceptance ratio of 30%) for every 50 iterations until iteration number 1000.
</para>
<para>
An output folder will be generated with a filename formatted using 'YYYYMMDD-HHMM', followed by a automatic description. In the above case the output folder could be name '20140701_1450_sippi_metropolis_eikonal'.
The actual folder name is return in <varname>options.txt</varname>.
</para>
<para>
One can define a description for the folder name by setting <varname>options.txt</varname> before running sippi_metropolis.
</para>
<para>
The folder contains one mat file, with the same name as the folder name, and N ascii files (where N=length(prior); one for each a priori type) which contains the models saved to disc. They also have the same name as the folder name, appended with '_m1.asc', '_m2.asc', and so forth.
</para>


<sect4 xml:id="AM13_plot_posterior"><title>Posterior statistics</title>
<para>
The function <link linkend="sippi_plot_posterior">sippi_plot_posterior</link> can be called when <link linkend="sippi_metropolis">sippi_metropolis</link> (or  <link linkend="sippi_rejection">sippi_rejection</link>) and will plot the progress of the log-likelihood curve, a sample of the posterior, data response from a sample of the posterior, and (if applicable) 1D and 2D marginal posterior distributions.
</para>
<para>
Located in the output folder of the inversion use
<screen>
sippi_plot_posterior;
</screen>
</para>
<para>
If the location of the folder with the output is known (such as options.txt) one can call
<screen>
sippi_plot_posterior(options.txt)
</screen>
</para>
</sect4>

</sect3>

</sect2>


<!-- INVERSION EXAMPLES FROM ARRENAES -->
<sect2 xml:id="AM13_gaussian_modeling_error"><title>AM13 Gaussian, acounting for modeling errors</title>
<para>
[A Matlab script for the following example is avalable at <link xlink:href="http://svn.code.sf.net/p/sippi/code/trunk/examples/case_tomography/sippi_AM13_metropolis_modeling_error.m">examples/case_tomography/sippi_AM13_metropolis_modeling_erro.m</link>).]
</para>
<para>
The use of any of the <link linkend="forward_traveltime">forward models</link> defined above, will be anapproximation to solvoing the perfect forwrad problem. 
This leads to a 'modeling' error as demonstrated.<citation>HCM14</citation>. If one has access to an optimal (but perhaps computational inefficient) forward model, and a faster (less accurate) forward model, then a Gaussian model of the modeling error caused by using the approximate, as opposed to the optima, forward model can be estimated using 
<link linkend="sippi_compute_modelization_forward_error">sippi_compute_modelization_forward_error</link>.
sippi_compute_modelization_forward_error.
</para>
<para>
SIPPI allows accounting for such modeling error through the <varname>dt</varname> and <varname>Ct</varname> fields for the <link linkend="sec_model_noise_gauss">data</link> structure. 
</para>
<para>
The setup of the data, prior and forward structures is identical to the one described in the <link linkend="AM13_gaussian">previous</link> example.
<screen>
%% Load the travel time data set from ARRENAES
clear all;close all
D=load('AM13_data.mat');
options.txt='AM13';

%% SETUP DATA
id=1;
data{id}.d_obs=D.d_obs;
data{id}.d_std=D.d_std;
data{id}.Ct=D.Ct+1; % Covaiance describing modelization error

%% SETUP PRIOR
im=1;
prior{im}.type='FFTMA';
prior{im}.name='Velocity (m/ns)';
prior{im}.m0=0.145;
prior{im}.Va='.0003 Sph(6)';
dx=0.15;
prior{im}.x=[-1:dx:6];
prior{im}.y=[0:dx:13];
prior{im}.cax=[.1 .18];

% SETUP THE FORWARD MODEL USED IN INVERSION
forward.forward_function='sippi_forward_traveltime';
forward.sources=D.S;
forward.receivers=D.R;
forward.type='fat';forward.linear=1;forward.freq=0.1;
</screen>
</para>
<para>
In order to compute the modeling with respect to using the <link linkend="forward_traveltime_born">'Born'</link> type forward model, one can define a new forward struture, here <varname>forward_full</varname>, and estimate a Gaussian model for the modeling error using
<screen>
% SETUP THE 'OPTIMAL' FORWARD MODEL
forward_full.forward_function='sippi_forward_traveltime';
forward_full.sources=D.S;
forward_full.receivers=D.R;
forward_full.type='Born';forward_full.linear=1;forward_full.freq=0.1;

% COMPUTE MODELING ERROR DUE TO USE OF forward AS OPPOSED TO forward_full
N=100;
[Ct,dt,dd]=sippi_compute_modelization_forward_error(forward_full,forward,prior,data,N);

% ASSIGN MODELING ERROR TO DATA
data{1}.dt=dt{1	};
data{1}.Ct=Ct{1};
</screen>
</para>
<para>
Sampling of the posterior can proceed exactly as for the previous example, using 
<screen>
options.mcmc.nite=500000; % optional, default:nite=30000
options.mcmc.i_sample=500; % optional, default:i_sample=500;
options.mcmc.i_plot=1000; % optional, default:i_plot=50;
options=sippi_metropolis(data,prior,forward,options);

% plot posterior statistics
sippi_plot_posterior(options.txt);
</screen>
</para>

</sect2>



<!-- INVERSION EXAMPLES FROM ARRENAES -->
<sect2 xml:id="AM13_bimodal"><title>AM13 Gaussian with bimodal velocity distribtion</title>
<para>
</para>
</sect2>

<!-- INVERSION EXAMPLES FROM ARRENAES -->
<sect2 xml:id="AM13_gaussian_model_par"><title>AM13 Gaussian with unknown Gaussian model parameters</title>
<para>
</para>
</sect2>




</sect1>
