<sect2 xml:id="getinunits"><title>getinunits</title>
<para><programlisting><![CDATA[ GETINUNITS   Get object properties in specified units
    V = GETINUNITS(H, PROP, UNITS) returns the object property
    in the specified UNITS. It will leave the 'Units' and 'FontUnits'
    property unchanged afterwards.
 
    H is the handle of the object. If it is an M-element array of handles,
    the function will return an M-by-1 cell array. PROP can be a string or
    a cell array of strings. If it is a 1-by-N or N-by-1 cell array, the
    function will return an M-by-N cell array of values. UNITS can be a
    string or a cell array. If it is a cell array, then PROP must also be a
    cell array with the same size as UNITS, and each cell element of UNITS
    corresponds to a cell element of PROP.
 
    V = GETINUNITS(H, PROP) is the same as GET(H, PROP)
 
    Examples:
      V = GETINUNITS(H, 'Position', 'Pixels')
      V = GETINUNITS(H, {'FontSize', 'Position'}, 'Normalized')
      V = GETINUNITS(H, {'FontSize', 'Position'}, {'Points', 'Pixels'})
 
    See also GET, SET
]]></programlisting></para>
</sect2>

<sect2 xml:id="logdet"><title>logdet</title>
<para><programlisting><![CDATA[ LOGDET Computation of logarithm of determinant of a matrix
 
    v = logdet(A);
        computes the logarithm of determinant of A. 
 
        Here, A should be a square matrix of double or single class.
        If A is singular, it will returns -inf.
 
        Theoretically, this function should be functionally 
        equivalent to log(det(A)). However, it avoids the 
        overflow/underflow problems that are likely to 
        happen when applying det to large matrices.
 
        The key idea is based on the mathematical fact that
        the determinant of a triangular matrix equals the
        product of its diagonal elements. Hence, the matrix's
        log-determinant is equal to the sum of their logarithm
        values. By keeping all computations in log-scale, the
        problem of underflow/overflow caused by product of 
        many numbers can be effectively circumvented.
 
        The implementation is based on LU factorization.
 
    v = logdet(A, 'chol');
        If A is positive definite, you can tell the function 
        to use Cholesky factorization to accomplish the task 
        using this syntax, which is substantially more efficient
        for positive definite matrix. 
 
    Remarks
    -------
        logarithm of determinant of a matrix widely occurs in the 
        context of multivariate statistics. The log-pdf, entropy, 
        and divergence of Gaussian distribution typically comprises 
        a term in form of log-determinant. This function might be 
        useful there, especially in a high-dimensional space.       
 
        Theoretially, LU, QR can both do the job. However, LU 
        factorization is substantially faster. So, for generic
        matrix, LU factorization is adopted. 
 
        For positive definite matrices, such as covariance matrices,
        Cholesky factorization is typically more efficient. And it
        is STRONGLY RECOMMENDED that you use the chol (2nd syntax above) 
        when you are sure that you are dealing with a positive definite
        matrix.
 
    Examples
    --------
        % compute the log-determinant of a generic matrix
        A = rand(1000);
        v = logdet(A);
 
        % compute the log-determinant of a positive-definite matrix
        A = rand(1000);
        C = A * A';     % this makes C positive definite
        v = logdet(C, 'chol');
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="plotboxpos"><title>plotboxpos</title>
<para><programlisting><![CDATA[ PLOTBOXPOS Returns the position of the plotted axis region
 
  pos = plotboxpos(h)
 
  This function returns the position of the plotted region of an axis,
  which may differ from the actual axis position, depending on the axis
  limits, data aspect ratio, and plot box aspect ratio.  The position is
  returned in the same units as the those used to define the axis itself.
  This function can only be used for a 2D plot.  
 
  Input variables:
 
    h:      axis handle of a 2D axis (if ommitted, current axis is used).
 
  Output variables:
 
    pos:    four-element position vector, in same units as h
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_adjust_step_size"><title>sippi_adjust_step_size</title>
<para><programlisting><![CDATA[  sippi_adjust_step_size Adjust step length length for Metropolis sampler in SIPPI
   
  Call : 
    step=sippi_adjust_step_size(step,P_average,P_target);
 
  step : current step 
  P_current : Current acceptance ratio
  P_target  : preferred acceptance ratio (def=0.3);
 
  See also sippi_compute_acceptance_rate, sippi_prior_set_steplength
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_anneal_adjust_noise"><title>sippi_anneal_adjust_noise</title>
<para><programlisting><![CDATA[  sippi_anneal_adjust_noise : Adjust noise level in annealing schedul
 
  Call: 
     [data_adjust,mcmc]=sippi_anneal_adjust_noise(data,i,mcmc,prior);
 
  See also: sippi_metropolis, sippi_anneal_factor
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_anneal_factor"><title>sippi_anneal_factor</title>
<para><programlisting><![CDATA[  sippi_anneal_factor : compute simple noise multiplication factor for
  annealing type sampling
 
  See also sippi_metropolis, sippi_anneal_adjust_noise
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_compute_acceptance_rate"><title>sippi_compute_acceptance_rate</title>
<para><programlisting><![CDATA[  sippi_compute_acceptance_rate Computes acceptance rate for the Metropolis sampler in SIPPI
 
  Call:
    P_acc=sippi_compute_acceptance_rate(acc,n_update_history);
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_compute_modelization_forward_error"><title>sippi_compute_modelization_forward_error</title>
<para><programlisting><![CDATA[  sippi_compute_modelization_forward_error Computes an estimate of the modelization erro
 
  Computes and estimate of the Gaussian modelization error, N(dt,Ct)
  caused by the use of an imperfect forward kernel
 
  If called with only one output '[Ct]=sippi..]' then the Gaussian model is
  assumed by centered around 0, (dt{1}=0).
 
  Call
    [Ct,dt,dd]=sippi_compute_modelization_forward_error(forward_full,forward_app,prior,data,N);
 
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_forward"><title>sippi_forward</title>
<para><programlisting><![CDATA[  sippi_forward Simple forward wrapper for SIPPI
 
  Assumes that the actual forward solver has been defined by
  forward.forward_function
 
  Call:
    [d,forward,prior,data]=sippi_forward(m,forward,prior,data,id,im)
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_get_sample"><title>sippi_get_sample</title>
<para><programlisting><![CDATA[  sippi_get_sample: Get a posterior sample
 
  Call :
   [reals,etype_mean,etype_var,reals_all,reals_ite]=sippi_get_sample(data,prior,id,im,n_reals,options);
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_least_squares"><title>sippi_least_squares</title>
<para><programlisting><![CDATA[  sippi_least_squares Least squares type inversion for SIPPI
 
  Call : 
     [m_reals,m_est,Cm_est]=sippi_least_squares(data,prior,forward,n_reals,lsq_type,id,im);
 
 
 
    lsq_type : 'lsq' (def), classical least squares 
               'error_sim', simulation through error simulation
               'visim', simulation through SGSIM of DSSIM
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_likelihood"><title>sippi_likelihood</title>
<para><programlisting><![CDATA[  sippi_likelihood Compute likelihood given an observed dataset
 
  Call
    [logL,L,data]=sippi_likelihood(d,data);
 
 
   data{1}.d_obs [N_data,1] N_data data observations
   data{1}.d_std [N_data,1] N_data uncorrelated Gaussian STD
 
   data{1}.d_var [N_data,1] N_data uncorrelated Gaussian variances
 
 
  Gaussian modelization error, N(dt,Ct), is specified as
   data{1}.dt [N_data,1] : Bias/mean of modelization error
   data{1}.Ct [N_data,N_data] : Covariance of modelization error
 
   data{1}.Ct [1,1] : Constant Covariance of modelization error
                      imples data{1}.Ct=ones(N_data.N_data)*data{1}.Ct;
 
 
 
 
  data{id}.recomputeCD [default=0], if '1' then data{1}.iCD is recomputed
  each time sippi_likelihood is called. This should be used if the noise model
  changes between each call to sippi_likelihood.
 
   data{id}.full_likelihood [default=]0; if '1' the the full likelihood
   (including the determinant) is computed. This not needed if the data
   civariance is constant, but if it changes, then use
   data{id}.full_likelihood=1;
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_likelihood_old"><title>sippi_likelihood_old</title>
<para><programlisting><![CDATA[  sippi_likelihood Compute likelihood given an observed dataset
 
  Call
    [logL,L,data]=sippi_likelihood(d,data);
 
 
   data{1}.d_obs [N_data,1] N_data data observations
   data{1}.d_std [N_data,1] N_data uncorrelated Gaussian STD
 
   data{1}.d_var [N_data,1] N_data uncorrelated Gaussian variances
 
 
  Gaussian modelization error, N(dt,Ct), is specified as
   data{1}.dt [N_data,1] : Bias/mean of modelization error
   data{1}.Ct [N_data,N_data] : Covariance of modelization error
 
   data{1}.Ct [1,1] : Constant Covariance of modelization error
                      imples data{1}.Ct=ones(N_data.N_data)*data{1}.Ct;
 
 
 
 
  data{id}.recomputeCD [default=0], if '1' then data{1}.iCD is recomputed
  each time sippi_likelihood is called. This should be used if the noise model
  changes between each call to sippi_likelihood.
 
   data{id}.full_likelihood [default=]0; if '1' the the full likelihood
   (including the determinant) is computed. This not needed if the data
   civariance is constant, but if it changes, then use
   data{id}.full_likelihood=1;
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_mcmc_init"><title>sippi_mcmc_init</title>
<para><programlisting><![CDATA[  sippi_mcmc_init Initialize McMC options for Metropolis and rejection sampling in SIPPI
 
  Call:
     options=sippi_mcmc_init(options,prior);
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_metropolis"><title>sippi_metropolis</title>
<para><programlisting><![CDATA[  sippi_metropolis Extended Metropolis sampling in SIPPI
 
  Metropolis sampling.
    See e.g. Hansen, T. M., Cordua, K. S., and Mosegaard, K., 2012. 
      Inverse problems with non-trivial priors - Efficient solution through Sequential Gibbs Sampling. 
      Computational Geosciences. doi:10.1007/s10596-011-9271-1.
 
  Call :
     [options,data,prior,forward,m_current]=sippi_metropolis(data,prior,forward,options)
  Input : 
     data : sippi data structure
     prior : sippi prior structure
     forward : sippi forward structure
 
  options : 
     options.txt [string] : string to be used as part of all output files
 
     options.mcmc.nite [1]  : Number if iterations
     options.mcmc.i_plot [1]: Number of iterations between updating plots
     options.mcmc.i_sample=: Number of iterations between saving model to disk
 
     options.mcmc.m_init : Manually chosen starting model
     options.mcmc.m_ref  : Reference known target model
 
     options_mcmc.accept_only_improvements [0] : Optimization
 
    %% PERTUBATION STRATEGY
    options.mcmc.pert_strategy.perturb_all=1; % Perturb all priors in each 
                                               % iteration. def =[0]
     %% SIMULATED ANNEALING 
     options.mcmc.anneal.i_begin=1; % default, iteration number when annealing begins
     options.mcmc.anneal.i_end=100000; %  iteration number when annealing stops
     options.mcmc.anneal.fac_begin=20; % default, noise is scaled by fac_begin at iteration i_begin
     options.mcmc.anneal.fac_end=1; % default, noise is scaled by fac_end at iteration i_end
 
 
  See also sippi_rejection
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_prior"><title>sippi_prior</title>
<para><programlisting><![CDATA[  sippi_prior A priori models for SIPPI 
 
  To generate a realization of the prior model defined by the prior structure use: 
    [m_propose,prior]=sippi_prior(prior);
 
  To generate a realization of the prior model defined by the prior structure,
  in the vicinity of a current model (using sequential Gibbs sampling) use: 
    [m_propose,prior]=sippi_prior(prior,m_current);
 
  The following types of a priori models can be used
    SNESIM  [1D-3D] : based on a multiple point statistical model inferref from a training images. Relies in the SNESIM algorithm
    SISIM   [1D-3D] : based on Sequential indicator SIMULATION
    VISIM   [1D-3D] : based on Sequential Gaussian and Direct Sequential simulation
    FFTMA   [1D-3D] : based on the FFT-MA method (Multivariate Gaussian) 
    GAUSSIAN   [1D] : 1D generalized gaussian model
 
 
 %%% SIMPLE EXAMPLE %%%
 
 % A simple 2D multivariate Gaissian based prior model based on the 
 % FFT-MA method, can be defined using 
    im=1;
    prior{im}.type='FFTMA';
    prior{im}.name='A SIMPLE PRIOR';
    prior{im}.x=[0:1:100];
    prior{im}.y=[0:1:100];
    prior{im}.m0=10;
    prior{im}.Va='1 Sph(10)';
    prior=sippi_prior_init(prior);
 % A realization from this prior model can be generated using
    m=sippi_prior(prior);
 % This realization can now be plotted using
    sippi_plot_prior(m,prior);
 % or
    imagesc(prior{1}.x,prior{1}.y,m{1})
 
 %%% A PRIOR MODEL WITH SEVERAL 'TYPES OF A PRIORI MODEL'
 
    im=1;
    prior{im}.type='GAUSSIAN';
    prior{im}.m0=100;
    prior{im}.std=50;
    prior{im}.norm=100;
    im=im+1;
    prior{im}.type='FFTMA';
    prior{im}.x=[0:1:100];
    prior{im}.y=[0:1:100];
    prior{im}.m0=10;
    prior{im}.Cm='1 Sph(10)';
    im=im+1;
    prior{im}.type='VISIM';
    prior{im}.x=[0:1:100];
    prior{im}.y=[0:1:100];
    prior{im}.m0=10;
    prior{im}.Cm='1 Sph(10)';
    im=im+1;
    prior{im}.type='SISIM';
    prior{im}.x=[0:1:100];
    prior{im}.y=[0:1:100];
    prior{im}.m0=10;
    prior{im}.Cm='1 Sph(10)';
    im=im+1;
    prior{im}.type='SNESIM';
    prior{im}.x=[0:1:100];
    prior{im}.y=[0:1:100];
 
    sippi_plot_prior(prior);
 
 %% Sequential Gibbs sampling
 
    All a priori model types can be perturbed, such that a new realization 
    is generated in the vicinity of a current model. 
    To do this Sequential Gibbs Sampling is used.
    For more information, see <a href="matlab:web('http://dx.doi.org/10.1007/s10596-011-9271-1')">Hansen, T. M., Cordua, K. S., and Mosegaard, K., 2012. Inverse problems with non-trivial priors - Efficient solution through Sequential Gibbs Sampling. Computational Geosciences</a>.
    The type of sequential Gibbs sampling can be controlled in the
    'seq_gibbs' structures, e.g. prior{1}.seq_gibbs
 
    im=1;
    prior{im}.type='SNESIM';
    prior{im}.x=[0:1:100];
    prior{im}.y=[0:1:100];
 
    [m,prior]=sippi_prior(prior);
    prior{1}.seq_gibbs.step=1; % Large step--> independant realizations
    prior{1}.seq_gibbs.step=.1; % Smaller step--> Dependant realizations
    for i=1:30;
       [m,prior]=sippi_prior(prior,m); % One iteration of Sequential Gibbs
       sippi_plot_prior(prior,m);
    end
 
  See also: sippi_prior_init, sippi_plot_prior, sippi_plot_prior_sample, sippi_prior_set_steplength.m
 
  TMH/2012
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_prior_init"><title>sippi_prior_init</title>
<para><programlisting><![CDATA[  sippi_prior_init Initialize PRIOR structure for SIPPI
 
  Call 
    prior=sippi_prior_init(prior);
 
  See also sippi_prior
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_prior_set_steplength"><title>sippi_prior_set_steplength</title>
<para><programlisting><![CDATA[  sippi_prior_set_steplength Set step length for Metropolis sampler in SIPPI
 
  Call
    prior=sippi_prior_set_steplength(prior,mcmc,im);
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_rejection"><title>sippi_rejection</title>
<para><programlisting><![CDATA[  sippi_rejection Rejection sampling
 
  Call : 
      options=sippi_rejection(data,prior,forward,options)
 
  input arguments
 
    options.mcmc.i_plot
    options.mcmc.nite     % maximum number of iterations
    options.mcmc.logLmax
 
    options.mcmc.rejection_normalize_log = log(options.mcmc.Lmax)
 
    options.mcmc.adaptive_rejection=1, adaptive setting of maxiumum likelihood
                   (def=[0])
                   At each iteration Lmax will be set if log(L(m_cur)=>options.mcmc.logLmax
 
 
    options.mcmc.max_run_time_hours = 1; % maximum runtime in hours
                                         % (overrides options.mcmc.nite if needed)
 
  See also sippi_metropolis
 
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_set_path"><title>sippi_set_path</title>
<para><programlisting><![CDATA[  sippi_set_path Set paths for running sippi
]]></programlisting></para>
</sect2>

