<sect2 xml:id="quantile"><title>quantile</title>
<para><programlisting><![CDATA[ QUANTILE Empirical (sample) quantiles.
 
    For vectors Q = QUANTILE(X, P) is the empirical quantiles of X for the
    probabilities in P.  The smallest observation corresponds to P = 0 and
    the largest to P = 1.  The length of Q is LENGTH(P).
 
    For matrices, QUANTILE(X, P) is the empirical quantiles of each column.
 
    In general, QUANTILE(X, P) is the empirical quantiles along the first
    non-singleton dimension.
 
    QUANTILE(X, P, DIM) returnes the quantiles along dimension DIM.
 
    This is a MATLAB version of the R `quantile' function.
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_adjust_step_size"><title>sippi_adjust_step_size</title>
<para><programlisting><![CDATA[  sippi_adjust_step_size Adjust step length length for Metropolis sampler in SIPPI
   
  Call : 
    step=sippi_adjust_step_size(step,P_average,P_target);
 
  step : current step 
  P_current : Current acceptance ratio
  P_target  : preferred acceptance ratio (def=0.3);
 
  See also sippi_compute_acceptance_rate, sippi_prior_set_steplength
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_anneal_adjust_noise"><title>sippi_anneal_adjust_noise</title>
<para><programlisting><![CDATA[  sippi_anneal_adjust_noise : Adjust noise level in annealing schedul
 
  Call: 
     [data_adjust,mcmc]=sippi_anneal_adjust_noise(data,i,mcmc,prior);
 
  See also: sippi_metropolis, sippi_anneal_factor
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_anneal_factor"><title>sippi_anneal_factor</title>
<para><programlisting><![CDATA[  sippi_anneal_factor : compute simple noise multiplication factor for
  annealing type sampling
 
  See also sippi_metropolis, sippi_anneal_adjust_noise
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_compute_acceptance_rate"><title>sippi_compute_acceptance_rate</title>
<para><programlisting><![CDATA[  sippi_compute_acceptance_rate Computes acceptance rate for the Metropolis sampler in SIPPI
 
  Call:
    P_acc=sippi_compute_acceptance_rate(acc,n_update_history);
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_compute_modelization_forward_error"><title>sippi_compute_modelization_forward_error</title>
<para><programlisting><![CDATA[  sippi_compute_modelization_forward_error Computes an estimate of the modelization erro
 
  Computes and estimate of the Gaussian modelization error, N(dt,Ct)
  caused by the use of an imperfect forward kernel
 
  If called with only one output '[Ct]=sippi..]' then the Gaussian model is
  assumed by centered around 0, (dt{1}=0).
 
  Call
    [Ct,dt,dd]=sippi_compute_modelization_forward_error(forward_full,forward_app,prior,data,N);
 
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_forward"><title>sippi_forward</title>
<para><programlisting><![CDATA[  sippi_forward Simple forward wrapper for SIPPI
 
  Assumes that the actual forward solver has been defined by
  forward.forward_function
 
  Call:
    [d,forward,prior,data]=sippi_forward(m,forward)
 
  Optional: 
    [d,forward,prior,data]=sippi_forward(m,forward,prior)
    [d,forward,prior,data]=sippi_forward(m,forward,prior,data)
    [d,forward,prior,data]=sippi_forward(m,forward,prior,data,options)
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_get_sample"><title>sippi_get_sample</title>
<para><programlisting><![CDATA[  sippi_get_sample: Get a posterior sample
 
  Call :
   [reals,etype_mean,etype_var,reals_all,reals_ite]=sippi_get_sample(wordking_directory,im,n_reals,skip_seq_gibbs);
 
     im: A priori model type
     n_reals: Number of realizations to return
     skip_seq_gibbs [1] Skip all realization where sequential gibbs is enabled
                    [0] Use all realization
     data: SIPPI data structure
     prior: SIPPI prior structure
     options: options structure when running sippi_metropolis
 
 
  If located in a SIPPI output folder one can simple use :
     [reals,etype_mean,etype_var,reals_all,reals_ite]=sippi_get_sample(im,n_reals);
  or
     skip_seq_gibbs=0;
     [reals,etype_mean,etype_var,reals_all,reals_ite]=sippi_get_sample(im,n_reals,skip_seq_gibbs);
 
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_get_sample_old"><title>sippi_get_sample_old</title>
<para><programlisting><![CDATA[  sippi_get_sample: Get a posterior sample
 
  Call :
   [reals,etype_mean,etype_var,reals_all,reals_ite]=sippi_get_sample(im,n_reals,skip_seq_gibbs,data,prior,options);
 
     im: A priori model type
     n_reals: Number of realizations to return
     skip_seq_gibbs [1] Skip all realization where sequential gibbs is enabled
                    [0] Use all realization
     data: SIPPI data structure
     prior: SIPPI prior structure
     options: options structure when running sippi_metropolis
 
 
  If located in a SIPPI output folder one can simple use :
     [reals,etype_mean,etype_var,reals_all,reals_ite]=sippi_get_sample(im,n_reals);
  or
     skip_seq_gibbs=0;
     [reals,etype_mean,etype_var,reals_all,reals_ite]=sippi_get_sample(im,n_reals,skip_seq_gibbs);
 
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_least_squares"><title>sippi_least_squares</title>
<para><programlisting><![CDATA[  sippi_least_squares Least squares type inversion for SIPPI
 
  Call : 
     [m_reals,m_est,Cm_est]=sippi_least_squares(data,prior,forward,n_reals,lsq_type,id,im);
 
 
 
    lsq_type : 'lsq' (def), classical least squares 
               'error_sim', simulation through error simulation
               'visim', simulation through SGSIM of DSSIM
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_likelihood"><title>sippi_likelihood</title>
<para><programlisting><![CDATA[  sippi_likelihood Compute likelihood given an observed dataset
 
  Call
    [logL,L,data]=sippi_likelihood(d,data);
 
 
   data{1}.d_obs [N_data,1] N_data data observations
   data{1}.d_std [N_data,1] N_data uncorrelated Gaussian STD
 
   data{1}.d_var [N_data,1] N_data uncorrelated Gaussian variances
 
 
  Gaussian modelization error, N(dt,Ct), is specified as
   data{1}.dt [N_data,1] : Bias/mean of modelization error
   data{1}.Ct [N_data,N_data] : Covariance of modelization error
 
   data{1}.Ct [1,1] : Constant Covariance of modelization error
                      imples data{1}.Ct=ones(N_data.N_data)*data{1}.Ct;
 
 
 
 
  data{id}.recomputeCD [default=0], if '1' then data{1}.iCD is recomputed
  each time sippi_likelihood is called. This should be used if the noise model
  changes between each call to sippi_likelihood.
 
   data{id}.full_likelihood [default=]0; if '1' the the full likelihood
   (including the determinant) is computed. This not needed if the data
   civariance is constant, but if it changes, then use
   data{id}.full_likelihood=1;
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_mcmc_init"><title>sippi_mcmc_init</title>
<para><programlisting><![CDATA[  sippi_mcmc_init Initialize McMC options for Metropolis and rejection sampling in SIPPI
 
  Call:
     options=sippi_mcmc_init(options,prior);
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_metropolis"><title>sippi_metropolis</title>
<para><programlisting><![CDATA[  sippi_metropolis Extended Metropolis sampling in SIPPI
 
  Metropolis sampling.
    See e.g. Hansen, T. M., Cordua, K. S., and Mosegaard, K., 2012. 
      Inverse problems with non-trivial priors - Efficient solution through Sequential Gibbs Sampling. 
      Computational Geosciences. doi:10.1007/s10596-011-9271-1.
 
  Call :
     [options,data,prior,forward,m_current]=sippi_metropolis(data,prior,forward,options)
  Input : 
     data : sippi data structure
     prior : sippi prior structure
     forward : sippi forward structure
 
  options : 
     options.txt [string] : string to be used as part of all output files
 
     options.mcmc.nite=30000;   % [1] : Number if iterations
     options.mcmc.i_sample=100; % : Number of iterations between saving model to disk
     options.mcmc.i_plot=50;  % [1]: Number of iterations between updating plots
     options.mcmc.i_save_workspace=10000;  % [1]: Number of iterations between
                                             saving the complete workspace
     options.mcmc.i_sample=100; % : Number of iterations between saving model to disk
 
     options.mcmc.m_init : Manually chosen starting model
     options.mcmc.m_ref  : Reference known target model
 
     options_mcmc.accept_only_improvements [0] : Optimization
 
    %% PERTUBATION STRATEGY
    options.mcmc.pert_strategy.perturb_all=1; % Perturb all priors in each 
                                               % iteration. def =[0]
     %% SIMULATED ANNEALING 
     options.mcmc.anneal.i_begin=1; % default, iteration number when annealing begins
     options.mcmc.anneal.i_end=100000; %  iteration number when annealing stops
     options.mcmc.anneal.fac_begin=20; % default, noise is scaled by fac_begin at iteration i_begin
     options.mcmc.anneal.fac_end=1; % default, noise is scaled by fac_end at iteration i_end
 
 
  See also sippi_rejection
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_prior"><title>sippi_prior</title>
<para><programlisting><![CDATA[  sippi_prior A priori models for SIPPI 
 
  To generate a realization of the prior model defined by the prior structure use: 
    [m_propose,prior]=sippi_prior(prior);
 
  To generate a realization of the prior model defined by the prior structure,
  in the vicinity of a current model (using sequential Gibbs sampling) use: 
    [m_propose,prior]=sippi_prior(prior,m_current);
 
  The following types of a priori models can be used
    % two point statistics bases
    GAUSSIAN   [1D] : 1D generalized gaussian model
    UNIFORM [1D-3D] : 1D-3D uncorrelated uniform distribution
    CHOLESKY[1D-3D] : based on Cholesky decomposition
    FFTMA   [1D-3D] : based on the FFT-MA method (Multivariate Gaussian) 
    VISIM   [1D-3D] : based on Sequential Gaussian and Direct Sequential simulation
    SISIM   [1D-3D] : based on Sequential indicator SIMULATION
    % multiple point based statistics
    SNESIM  [1D-3D] : based on a multiple point statistical model inferref from a training images. Relies in the SNESIM algorithm
 
 
 %%% SIMPLE EXAMPLE %%%
 
 % A simple 2D multivariate Gaissian based prior model based on the 
 % FFT-MA method, can be defined using 
    im=1;
    prior{im}.type='FFTMA';
    prior{im}.name='A SIMPLE PRIOR';
    prior{im}.x=[0:1:100];
    prior{im}.y=[0:1:100];
    prior{im}.m0=10;
    prior{im}.Va='1 Sph(10)';
    prior=sippi_prior_init(prior);
 % A realization from this prior model can be generated using
    m=sippi_prior(prior);
 % This realization can now be plotted using
    sippi_plot_prior(m,prior);
 % or
    imagesc(prior{1}.x,prior{1}.y,m{1})
 
 %%% A PRIOR MODEL WITH SEVERAL 'TYPES OF A PRIORI MODEL'
 
    im=1;
    prior{im}.type='GAUSSIAN';
    prior{im}.m0=100;
    prior{im}.std=50;
    prior{im}.norm=100;
    im=im+1;
    prior{im}.type='FFTMA';
    prior{im}.x=[0:1:100];
    prior{im}.y=[0:1:100];
    prior{im}.m0=10;
    prior{im}.Cm='1 Sph(10)';
    im=im+1;
    prior{im}.type='VISIM';
    prior{im}.x=[0:1:100];
    prior{im}.y=[0:1:100];
    prior{im}.m0=10;
    prior{im}.Cm='1 Sph(10)';
    im=im+1;
    prior{im}.type='SISIM';
    prior{im}.x=[0:1:100];
    prior{im}.y=[0:1:100];
    prior{im}.m0=10;
    prior{im}.Cm='1 Sph(10)';
    im=im+1;
    prior{im}.type='SNESIM';
    prior{im}.x=[0:1:100];
    prior{im}.y=[0:1:100];
 
    sippi_plot_prior(prior);
 
 %% Sequential Gibbs sampling
 
    All a priori model types can be perturbed, such that a new realization 
    is generated in the vicinity of a current model. 
    To do this Sequential Gibbs Sampling is used.
    For more information, see <a href="matlab:web('http://dx.doi.org/10.1007/s10596-011-9271-1')">Hansen, T. M., Cordua, K. S., and Mosegaard, K., 2012. Inverse problems with non-trivial priors - Efficient solution through Sequential Gibbs Sampling. Computational Geosciences</a>.
    The type of sequential Gibbs sampling can be controlled in the
    'seq_gibbs' structures, e.g. prior{1}.seq_gibbs
 
    im=1;
    prior{im}.type='SNESIM';
    prior{im}.x=[0:1:100];
    prior{im}.y=[0:1:100];
 
    [m,prior]=sippi_prior(prior);
    prior{1}.seq_gibbs.step=1; % Large step--> independant realizations
    prior{1}.seq_gibbs.step=.1; % Smaller step--> Dependant realizations
    for i=1:30;
       [m,prior]=sippi_prior(prior,m); % One iteration of Sequential Gibbs
       sippi_plot_prior(prior,m);
    end
 
  See also: sippi_prior_init, sippi_plot_prior, sippi_plot_prior_sample, sippi_prior_set_steplength.m
 
  TMH/2012
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_prior_cholesky"><title>sippi_prior_cholesky</title>
<para><programlisting><![CDATA[  sippi_prior_cholesky : Cholesky type Gaussian prior for SIPPI
 
 % Example:
    ip=1;
    prior{ip}.type='cholesky';
    prior{ip}.m0=10;
    prior{ip}.Cm='.001 Nug(0) + 1 Gau(10)';
    prior{ip}.x=0:1:100;linspace(0,100,20);
    prior{ip}.y=0:1:50;linspace(0,33,30);
    [m,prior]=sippi_prior_cholesky(prior);
    sippi_plot_prior(prior,m);
 
 % Sequential Gibbs sampling
    prior{1}.seq_gibbs.step=.1;
    for i=1:100;
        [m,prior]=sippi_prior_cholesky(prior,m);
        sippi_plot_prior(prior,m);
        caxis([8 12]);drawnow;
    end
 
 % Prior covariance model
  The prior covarince model can be setup using
    prior{ip}.m0=10;
    prior{ip}.Cm='.001 Nug(0) + 1 Gau(10)';
  or
    prior{ip}.m0=10;
   and the 'Cmat' variable 'prior{ip}.Cmat' which much the contain a full
   nd X nd size covariance matrix. 
   (it is computed the first the sippi_prior_cholesky is called) 
 
  See also: gaussian_simulation_cholesky
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_prior_dsim"><title>sippi_prior_dsim</title>
<para><programlisting><![CDATA[  sippi_prior_dsim : Direct simulation in SIPPI
 
 
  TMH/2014
 
  See also: sippi_prior_init, sippi_prior
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_prior_init"><title>sippi_prior_init</title>
<para><programlisting><![CDATA[  sippi_prior_init Initialize PRIOR structure for SIPPI
 
  Call
    prior=sippi_prior_init(prior);
 
  See also sippi_prior
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_prior_set_steplength"><title>sippi_prior_set_steplength</title>
<para><programlisting><![CDATA[  sippi_prior_set_steplength Set step length for Metropolis sampler in SIPPI
 
  Call
    prior=sippi_prior_set_steplength(prior,mcmc,im);
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_prior_sisim"><title>sippi_prior_sisim</title>
<para><programlisting><![CDATA[  sippi_prior_sisim: SISIM (SGeMS) type prior for SIPPI
 
 % Example:
     ip=1;
     prior{ip}.type='sisim';
     prior{ip}.x=1:1:80;
     prior{ip}.y=1:1:80;
     prior{ip}.Cm='1 Sph(60)';
     prior{ip}.marginal_prob=[.1 .4 .5];
     m=sippi_prior(prior);
     sippi_plot_prior(prior,m)
 
     % optionally a specific random seed can be set using
     prior{ip}.seed=1;
 
 % Sequential Gibbs sampling type 1 (box selection of pixels)
     prior{ip}.seq_gibbs.type=1;%
     prior{ip}.seq_gibbs.step=10; % resim data in 10x10 pixel grids
     [m,prior]=sippi_prior(prior);
     for i=1:10;
        [m,prior]=sippi_prior(prior,m);
        sippi_plot_prior(prior,m);
        drawnow;
     end
 
 % Sequential Gibbs sampling type 2 (random pixels)
     prior{ip}.seq_gibbs.type=2;%
     prior{ip}.seq_gibbs.step=.6; % Resim 60% of data
     [m,prior]=sippi_prior(prior);
     for i=1:10;
        [m,prior]=sippi_prior(prior,m);
        sippi_plot_prior(prior,m);
        drawnow;
     end
 
  See also: sippi_prior, sgems
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_prior_snesim"><title>sippi_prior_snesim</title>
<para><programlisting><![CDATA[  sippi_prior_snesim : SNESIM type Gaussian prior for SIPPI
 
 % Example:
     ip=1;
     prior{ip}.type='snesim';
     prior{ip}.x=1:1:80;
     prior{ip}.y=1:1:80;
     prior{ip}.ti=channels;
     % prior{ip}.ti=maze;
     m=sippi_prior(prior);
     sippi_plot_prior(prior,m)
     figure(1);imagesc(prior{ip}.ti);axis image
 
 % Sequential Gibbs sampling type 1 (box selection of pixels)
     prior{ip}.seq_gibbs.type=1;%    
     prior{ip}.seq_gibbs.step=10; % resim data in 10x10 pixel grids
     [m,prior]=sippi_prior(prior);
     for i=1:10;
        [m,prior]=sippi_prior(prior,m);
        sippi_plot_prior(prior,m);
        drawnow;
     end
 
 % Sequential Gibbs sampling type 2 (random pixels)
     prior{ip}.seq_gibbs.type=2;%    
     prior{ip}.seq_gibbs.step=.6; % Resim 60% of data
     [m,prior]=sippi_prior(prior);
     for i=1:10;
        [m,prior]=sippi_prior(prior,m);
        sippi_plot_prior(prior,m);
        drawnow;
     end
 
  See also: sippi_prior, ti
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_prior_uniform"><title>sippi_prior_uniform</title>
<para><programlisting><![CDATA[  sippi_prior_uniform : Uniform prior for SIPPI
 
 
 % Example 1D uniform
    ip=1;
    prior{ip}.type='uniform';
    prior{ip}.min=10;
    prior{ip}.max=25;
    [m,prior]=sippi_prior_uniform(prior);
    sippi_plot_prior_sample(prior);
 
 % Example 10D uniform
    ip=1;
    prior{ip}.type='uniform';
    prior{ip}.x=1:1:10; % As dimensions are uncorrelated, only the lehgth
                        % of prior{ip}.x matters, not its actual values.
    prior{ip}.min=10;
    prior{ip}.max=25;
    [m,prior]=sippi_prior_uniform(prior);
    sippi_plot_prior_sample(prior);
 
 % Sequential Gibbs sampling
    prior{1}.seq_gibbs.step=.1;
    for i=1:1000;
        [m,prior]=sippi_prior(prior,m);
        mm(i)=m{1};
    end
    subplot(1,2,1);plot(mm);
    subplot(1,2,2);hist(mm);
 
  TMH/2014
 
  See also: sippi_prior_init, sippi_prior
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_prior_visim"><title>sippi_prior_visim</title>
<para><programlisting><![CDATA[  sippi_prior_visim : VISIM type Gaussian prior for SIPPI
 
 % Example:
     ip=1;
     prior{ip}.type='visim';
     prior{ip}.x=1:1:80;
     prior{ip}.y=1:1:80;
     prior{ip}.Cm='1 Sph(60)';
     m=sippi_prior(prior);
     sippi_plot_prior(prior,m)
 
     % optionally a specific random seed can be set using
     prior{ip}.seed=1;
 
 % Sequential Gibbs sampling type 1 (box selection of pixels)
     prior{ip}.seq_gibbs.type=1;%
     prior{ip}.seq_gibbs.step=10; % resim data in 10x10 pixel grids
     [m,prior]=sippi_prior(prior);
     for i=1:10;
        [m,prior]=sippi_prior(prior,m);
        sippi_plot_prior(prior,m);
        drawnow;
     end
 
 % Sequential Gibbs sampling type 2 (random pixels)
     prior{ip}.seq_gibbs.type=2;%
     prior{ip}.seq_gibbs.step=.6; % Resim 60% of data
     [m,prior]=sippi_prior(prior);
     for i=1:10;
        [m,prior]=sippi_prior(prior,m);
        sippi_plot_prior(prior,m);
        drawnow;
     end
 
  See also: sippi_prior, visim
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_rejection"><title>sippi_rejection</title>
<para><programlisting><![CDATA[  sippi_rejection Rejection sampling
 
  Call : 
      options=sippi_rejection(data,prior,forward,options)
 
  input arguments
 
    options.mcmc.i_plot
    options.mcmc.nite     % maximum number of iterations
    options.mcmc.logLmax
 
    options.mcmc.rejection_normalize_log = log(options.mcmc.Lmax)
 
    options.mcmc.adaptive_rejection=1, adaptive setting of maxiumum likelihood
                   (def=[0])
                   At each iteration Lmax will be set if log(L(m_cur)=>options.mcmc.logLmax
 
 
    options.mcmc.max_run_time_hours = 1; % maximum runtime in hours
                                         % (overrides options.mcmc.nite if needed)
 
  See also sippi_metropolis
 
 
]]></programlisting></para>
</sect2>

<sect2 xml:id="sippi_set_path"><title>sippi_set_path</title>
<para><programlisting><![CDATA[  sippi_set_path Set paths for running sippi
]]></programlisting></para>
</sect2>

