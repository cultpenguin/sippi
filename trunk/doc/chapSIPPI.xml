<para>
This section contains information about how to use and control SIPPI, which requires one to   
<itemizedlist mark='bullet'>
      <listitem>
        <para>Define the <link linkend="chapprior">prior model</link>, in form of the prior data structure</para>
      </listitem>
      <listitem>
        <para>Define the <link linkend="chapforward">forward model</link>, in form of the forward data structure, and the sippi_forward.m m-file</para>
      </listitem>
      <listitem>
        <para>Define the <link linkend="chapdata">data and noise model</link>, in form of the prior data structure</para>
      </listitem>
<!--
      <listitem>
        <para>Choose a method for <link linkend="chapposterior">sampling the a posteriori probability density</link>.</para>
      </listitem>
-->
</itemizedlist>
</para>
<para>
[For examples of how to apply SIPPI for different problems, see <link linkend="chapExamples">the section with examples</link>].
</para>


<sect1 xml:id="chapprior"><title><varname>prior</varname>: The a priori model</title>
<para>
A priori information is defined by the <varname>prior</varname> Matlab structure. Any mumber of types of a priori models can be defined. For example a 1D uniform prior can be defined in <varname>prior{1}</varname>, and 2D Gaussian prior can be defined in <varname>prior{2}</varname>.   
</para>
<para>
Once a prior data stricture has been defined, a realization from the prior model can be generated using 
<screen>
m=sippi_prior(prior);
</screen>
The realization from the prior can be visualized using 
<screen>
sippi_plot_prior(prior);
sippi_plot_prior(prior,m);
</screen>
A sample from the prior can be visualized using
<screen>
m=sippi_plot_prior_sample(prior);
</screen>
</para>
<para>
Each prior type is defined by setting a number field in the <varname>prior</varname> Matlab structure. For example, an decsriptive name (which is can be optionallyt set) decsribing the prior can be set in the <varname>name</varname> field, e.g.
<screen>
prior{1}.name='My Prior';
</screen>
</para>

<sect2 xml:id="prior_types"><title>Types of a priori models</title>
<para>
5 types of a priori models are available, and can be selected by setting the <varname>type</varname> in the <varname>prior</varname> structure using e.q. <varname>prior{1}.type='gaussian'</varname>.  
</para>
<para>
</para>
<para>
The <link linkend="prior_gaussian">GAUSSIAN</link> type prior specifes a 1D generalized Gaussian model.
</para>
<para>
The <link linkend="prior_fftma">FFTMA</link> specifes 1D-3D Gaussian Gaussian modelm using efficient unconditional sampling,
</para>
<para>
The <link linkend="prior_visim">VISIM</link> type prior model specifes a 1D-3D Gaussian Gaussian model, utilizing both sequential Gaussian simulation and direct sequential simulation, and conditioning the data of point support and linear average data. 
</para>
<!--
<para>
The <link linkend="prior_sisim">SISIM</link> type prior model specifes a 1D-3D prior model based on Gaussian indicator statistics. This type of prior requires <link linkend="SGEMS">SGEMS</link> to be installed.
</para>
-->
<para>
The <link linkend="prior_snesim">SNESIM</link> type prior model specifes a 1D-3D multiple point statistical model, relying on traning images to infer a model multiple point statistics. This type of prior requires <link linkend="SGEMS">SGEMS</link> to be installed.
</para>
<para>
The following section documents the properties of each type of prior model.
</para>
<para>
Examples of different types of (combinations of) a priori model can be found in the <link linkend="sec_ex_prior">examples section</link>. 
</para>

<!-- GAUSSIAN -->
<sect3 xml:id="prior_gaussian"><title>1D Generalized Gaussian</title>
<para>
A 1D generalized Gaussian prior model can be specified using the 'gaussian' type prior model
</para>
<screen>
prior{1}.type='gaussian';
</screen>

<para>
A simple 1D Gaussian distribution with mean 10, and standard deviation 2, can be specified using
</para>
<screen>
ip=1;
prior{ip}.type='gaussian';
prior{ip}.m0=10;
prior{ip}.std=2;
</screen>

<para>
The norm of a generalized Gaussian can be set using the 'norm' field. A generalized 1D Gaussian with mean 10, standard devation of 2, and a norm of 70, can be specified using 
(The norm is equivelent ot the beta factor referenced in <link xlink:href="http://en.wikipedia.org/wiki/Generalized_normal_distribution">Wikipedia:Generalized_normal_distribution</link>)
</para>
<screen>
ip=2;
prior{ip}.type='gaussian';
prior{ip}.m0=10;
prior{ip}.std=2;
prior{ip}.norm=70;
</screen>

<para>
A 1D distribution with an arbitrary distrution shape, can be defined by setting <varname>d_target</varname>, which must contain a sample of the distribtion that onw would like to replicate. For example, to generate a sample from a non-symmetric bimodal distrbution, one can use e.g.
</para>
<screen>
% Create target distribution
N=10000;
prob_chan=0.3;
d1=randn(1,ceil(N*(1-prob_chan)))*.5+8.5;
d2=randn(1,ceil(N*(prob_chan)))*.5+11.5;
d_target=[d1(:);d2(:)];

% set the target distribution
ip=3;
prior{ip}.type='gaussian';
prior{ip}.d_target=d_target;
</screen>
<para>
The following figure shows the 1D histrogram of a sample, consisting of 8000 realizations, generated using 
<screen>
sippi_plot_prior_sample(prior,1:ip,8000);
</screen>
</para>
   <mediaobject>
      <imageobject condition="web">
	    <imagedata fileref="figures/prior_gaussian_1d.png" width="100%" scalefit="1"/>
<!--
        <imagedata fileref="figures/prior_gaussian_normal.png" width="33%" scalefit="1"/>
        <imagedata fileref="figures/prior_gaussian_generalized.png" width="33%" scalefit="1"/>
        <imagedata fileref="figures/prior_gaussian_target.png" width="33%" scalefit="1"/>
-->
		</imageobject>
      <textobject><phrase></phrase></textobject>
    </mediaobject>




</sect3>


<sect3 xml:id="prior_fftma"><title>FFTMA - 3D Gaussian model</title>
<para>
The FFT moving average method provides an efficient approach for computing unconditional realizations of a Gaussian random field.
</para>
<para>
The mean and the covariance model must be specified in the <varname>m0</varname> and <varname>Cm</varname> fields. The format for describing the covariance model follows 'gstat'-type notation, and is described in more details in the <link xlink:href="http://mgstat.sourceforge.net/htmldoc/Spatial.html">mGstat manual</link>.  
</para>
<para>
A 2D covariance model with mean 10, and a Spherical type covariance model can be defined in a 101x101 size grid (1m between cells) using
</para>
<screen>
im=1;
prior{im}.type='FFTMA';
prior{im}.x=[0:1:100];
prior{im}.y=[0:1:100];
prior{im}.m0=10;
prior{im}.Cm='1 Sph(10)';
</screen>
   <mediaobject>
      <imageobject condition="web">
        <imagedata fileref="figures/prior_fftma_2d_gaussian.png" width="100%" scalefit="1"/>
      </imageobject>
      <textobject><phrase></phrase></textobject>
    </mediaobject>

<para>
Optionally one can translate the output of the Gaussian simulation into an arbitrarily shaped 'target' distribution, using normal score transformation. Note that this transformation will ensure a certin distribtion, but will alter the assumed covariance model, such the covariance model properties are no longer esnured. To ensure the covariance model properties are honored, make use of the VISIM type prior model. 
</para>
<screen>
im=1;
prior{im}.type='FFTMA';
prior{im}.x=[0:1:100];
prior{im}.y=[0:1:100];
prior{im}.m0=10;
prior{im}.Cm='1 Sph(10)';

% Create target distribution
N=10000;
prob_chan=0.5;
d1=randn(1,ceil(N*(1-prob_chan)))*.5+8.5;
d2=randn(1,ceil(N*(prob_chan)))*.5+11.5;
d_target=[d1(:);d2(:)];
prior{im}.d_target=d_target;
</screen>
<para>
Alternatively, the normal score transformation can be defined manually to control tail behaviour using
</para>
<screen>
N=10000;
prob_chan=0.5;
d1=randn(1,ceil(N*(1-prob_chan)))*.5+8.5;
d2=randn(1,ceil(N*(prob_chan)))*.5+11.5;
d_target=[d1(:);d2(:)];
[d_nscore,o_nscore]=nscore(d_target,1,1,min(d_target),max(d_target),0);
prior{im}.o_nscore=o_nscore;
</screen>
   <mediaobject>
      <imageobject condition="web">
        <imagedata fileref="figures/prior_fftma_2d_target.png" width="100%" scalefit="1"/>
      </imageobject>
      <textobject><phrase></phrase></textobject>
    </mediaobject>
	
</sect3>

<sect3 xml:id="prior_visim"><title>VISIM</title>
<para>
</para>
<screen>
im=im+1;
prior{im}.type='VISIM';
prior{im}.x=[0:1:100];
prior{im}.y=[0:1:100];
prior{im}.m0=10;
prior{im}.Cm='1 Sph(10)';
</screen>
   <mediaobject>
      <imageobject condition="web">
        <imagedata fileref="figures/prior_visim_2d_gaussian.png" width="100%" scalefit="1"/>
      </imageobject>
      <textobject><phrase></phrase></textobject>
    </mediaobject>
<para>
As with the FFTMA type prior the VISIM type prior can make use of a target distribution. However, if a target distribution is set, the use of the VISIM type prior will utilize direct sequential simulation, which will ensure both histogram and covariance reproduction. 
</para>
<para>
Except for the <varname>type</varname> the use of a target distribtion is similat to that of the FFTMA type prior
</para>
<screen>
clear all;close all;
im=1;
prior{im}.type='VISIM';
prior{im}.x=[0:1:40];
prior{im}.y=[0:1:40];
prior{im}.m0=10;
prior{im}.Cm='1 Sph(10)';

% Create target distribution
N=10000;
prob_chan=0.5;
d1=randn(1,ceil(N*(1-prob_chan)))*.5+8.5;
d2=randn(1,ceil(N*(prob_chan)))*.5+11.5;
d_target=[d1(:);d2(:)];
prior{im}.d_target=d_target;
</screen>
  <mediaobject>
      <imageobject condition="web">
        <imagedata fileref="figures/prior_visim_2d_target.png" width="100%" scalefit="1"/>
      </imageobject>
      <textobject><phrase></phrase></textobject>
    </mediaobject>



<!--
<sect4 xml:id="prior_visim_2d"><title>VISIM:2D</title>
<para></para>
<screen>
im=im+1;
prior{im}.type='VISIM';
prior{im}.x=[0:1:100];
prior{im}.y=[0:1:100];
prior{im}.m0=10;
prior{im}.Cm='1 Sph(10)';
</screen>
</sect4>
-->

</sect3>

<!--
<sect3 xml:id="prior_sisim"><title>SISIM</title>
<para></para>
</sect3>
-->
<sect3 xml:id="prior_snesim"><title>SNESIM</title>
<para></para>
</sect3>

</sect2>

<sect2 xml:id="prior_sampling"><title>Sampling the prior</title>
<para>
Once the prior data structure has been defined a sample from the prior distribution can be generated using 
<screen>
m=sippi_prior(prior);
</screen>
'm' is a Matlab data structure of the same size as the 'prior' data structure. Thus, if two prior distributions have been defined in 'prior{1}' and 'prior{2}', then 'm{1}' will hold a realization of 'prior{1}', 
and 'm{2}' will hold a realization of 'prior{2}'. 
</para>
<para>
Each time 'm=sippi_prior(prior)' is called, a new independant realization of the prior will be generated.
</para>

</sect2>

<sect2 xml:id="sec_seq_gibbs"><title>Sequential Gibbs sampling / Conditional Resampling</title>
<para>
All the available a priori types available allow perturbing one realization of a prior into a new realization of prior, in the vicinity of the first one. To do this we make use of sequential Gibbs sampling <citation>HCM12</citation>. Sequential Gibbs in essence is a type of conditional resampling. From a current realization of a prior, a number of model parameters are discarded and treated as unknown, and the simulated conditional to the fixed values of the model parameters.  
</para>
<para>
In order to generate a new realiztion 'm2' in the viciinity of the realization 'm1' use
<screen>
m1=sippi_prior(prior);
[m2,prior]=sippi_prior(prior,m1);
</screen>
If this process is iterated, then a random walk in the space of a priori acceptable models will be perform. And, the collection of realization obatined, will represent a sample from prior distribution.  
</para>




<sect3 xml:id="sec_seq_gibbs_step"><title>Controlling sequential Gibbs sampling / Conditional Resampling</title>
<para>
All properties related to sequential Gibbs sampling can be set in the 'seq_gibbs' data struture, for each prior type. The follwing two parameters determined how the a current model is perturbed
</para>
<screen>
prior{m}.seq_gibbs.step=1;
prior{m}.seq_gibbs.type=2;
</screen>
</sect3>
</sect2>


</sect1>

<!-- DATA -->
<sect1 xml:id="chapdata"><title><varname>data</varname>: The data and the noise</title>
<para>
<varname>data</varname> is Matlab structure that defines any number of data and a corresponding noise model.
</para>
<para>
<varname>data{1}</varname> defines the first data set (which must always be defined), and ny number of additional data sets can be defined in 
<varname>data{2}</varname>, 
<varname>data{3}</varname>, ...
</para>
<para>
This allow to consider for example seismic data in <varname>data{1}</varname>, and electromagnetic data in <varname>data{2}</varname>. 
 </para>
<para>
For each set of data, a Gaussian noise model (both correlated and uncorrelated) can be specified). The noise model for different data types (e.g. <varname>data{1}</varname> and <varname>data{2}</varname> are independent).
</para>

<para>
Once the noise model has been defined the log-likelihood related to any model, <varname>m</varname>, with the corressponding <link linkend="chapforward">forward response</link>, <varname>d</varname>, can be computed using
<screen>
logL=sippi_likelihood(data,d)
</screen>
where <varname>d</varname> is the output of <link linkend="sippi_forward">sippi_forward</link>.

</para>
<para>
The specification of the noise model can be divided into a description of the <link linkend="sec_meas_noise_gauss">measurement noise</link> (mandatory) and the <link linkend="sec_model_noise_gauss">modeling error</link> (optional).
</para>

<sect2 xml:id="sec_meas_noise_gauss"><title>Gaussian measurement noise</title>
<para>
</para>
<sect3 xml:id="sec_meas_noise_gauss_uncorr"><title>Uncorrelated Gaussian measurement noise</title>
<para>
To define a set of observed data, [0,1,2], with an associated uncertainty defined by a Gaussian model with mean 0 and standard deviation 2, use
<screen>
data{1}.d_obs=[0 1 2]';
data{1}.d_std=[2 2 2]';
</screen>
which is equivalent to (as the noise model for each data the same, and independent) 
<screen>
data{1}.d_obs=[0 1 2]';
data{1}.d_std=2;
</screen>
One can also choose to define the uncertainty using a variance as opposed to the standard deviation
<screen>
data{1}.d_obs=[0 1 2]';
data{1}.d_var=4;
</screen>
</para>
</sect3>

<sect3 xml:id="sec_meas_noise_gauss_corr"><title>correlated Gaussian measurement noise</title>
<para>
Correlated Gaussian measurement uncertainty can be specified using the <varname>Cd</varname> field, as for example
<screen>
data{1}.Cd=[4 1 0 ; 1 4 1 ; 0 1 4];
</screen>
Note that <varname>data{1}.Cd</varname> must be of size [NDxND], where ND is the the number of data in <varname>data{1}.d_obs</varname>.
</para>

</sect3>

</sect2>

<sect2 xml:id="sec_model_noise_gauss"><title>Gaussian modeling error</title>
<para>
The modeling error refer to errors caused by using for example an imperfect forward model, see <citation>HCM14</citation>.
</para>
<para>
A Gaussian model of the modeling error can is specified by the mean, <varname>dt</varname>, and the covariance, <varname>Ct</varname>.
</para>
<para>
For example
<screen>
data{1}.dt=[0 0 0];
data{1}.Ct=[4 4 4; 4 4 4; 4 4 4];
</screen>
is equivalent to 
<screen>
data{1}.Ct=4
</screen>
which implies a zero mean modeling error with a coavraince model where all model paremeters has a covariace of 4. 
</para>
<para>See the <link linkend="sec_ex_tomography">tomography example</link>, for an example of accounting for correlated modeling errors.
</para>
</sect2>

</sect1>

<!-- FORWARD-->
<sect1 xml:id="chapforward"><title><varname>forward</varname>: The forward model</title>
<para>
The specification of the <varname>prior</varname> and <varname>data</varname> is intended to be generic, applicable to any inverse problem considered. The forward problem, on the other hand, is typically specific for each different inverse problem.
</para>
<para> 
In order to make use of SIPPI to sample the posterior distribtion, the solution to the forward problem, must be embedded in a Matlab function with the following input and output arguments:
</para>
<screen>
[d,forward,prior,data]=sippi_forward(m,forward,prior,data,id)
</screen>
<para>
<varname>m</varname> is a realization of the prior model, and <varname>prior</varname> and <varname>data</varname> are the Matlab structures defining the prior and the noise model (see <link linkend="chapprior">Prior</link> and <link linkend="chapdata">Data</link>)
</para>
<para>
<varname>id</varname> is optional, and can be used to compute the forward response of a subset of the diffrent types of data avaialable (i.e. <varname>data{1}</varname>, <varname>data{2}</varname>,... )
</para> 

<para>
The <varname>forward</varname> variable is a Matlab stucture that can contain any information needed to solve the forward problem. Thus, the parameters for the The <varname>forward</varname> structure is problem dependant. One option, <varname>forward.forward_function</varname> is though generic, and point to the m-file that implements the forward problem.
</para> 
<para>
The output variable <varname>d</varname> is a Matlab stucture of the same size of <varname>data</varname>.
Thus, if 4 types of data have been specified, then <varname>d</varname> must also be a structures of size 4.
<screen>
length(data) == length(d);
</screen> 
Further, <varname>d{i}</varname> must refer to an array of the same size as <varname>data{i}.d_obs</varname>.
</para> 
<para>
An example of an implementation of the forward problem related to a simple line fitting problem can be:

</para>
<screen>
function [d,forward,prior,data]=sippi_forward_linefit(m,forward,prior,data);
    d{1}=forward.x*m{2}+m{1};
</screen>
<para>
This implementation requires that the 'x'-locations, for which the y-values of the straight line is to be computed, is specified through <varname>forward.x</varname>. Say some some y-data has been observed at locations x=[1,5,8], with the values [2,4,9], and a standard devation of 1 specifying the uncertainty, the forward stucture must be set as 
<screen>
forward.forward_function='sippi_forward_linefit';
forward.x=[1,5,8];
</screen>
while the data structure will be
<screen>
data{1}.d_obs=[2 4 9]
data{1}.d_std=1;
</screen>
</para>

<para>
This implementation also requires that the prior model consists of two 1D prior types, such that 
<screen>
m=sippi_prior(prior)
</screen> 
returns the intercept in <varname>m{1}</varname> and the gradient in <varname>m{2}</varname>.
</para>
<para>
An example of computing the forward response using an intercept of 0, and a gradients of 2 is then 
<screen>
m{1}=0;
m{2}=2;
d=sippi_forward(m,forward)
</screen>
and the correspnding log-likelihood of m, can be computed using
</para>
<screen>
logL=sippi_likelihood(data,d);
</screen>

<para>
[see more deatils and example related to polynomial line fitting  at <link linkend="sec_ex_linefit">polynomial line fittting</link>].
</para>
<para>
The <link linkend="chapExamples">Examples</link> section contains more example of implementation of different forward problems.
</para>
</sect1>


<!-- CHECKINGF THE SETUP -->
<sect1 xml:id="secTestSetup"><title>Validating <varname>prior</varname>, <varname>data</varname>, and <varname>forward</varname></title>
<para>
A simple way to test the validity of 
<varname>prior</varname>,
<varname>data</varname>, and
<varname>forward</varname> 
is test if the following sequence can be eavlauted without errors: 
</para>
<screen>
% Generate a realization, m, of the prior model
m=sippi_prior(prior);
% Compute the forward response
d=sippi_forward(m,forward,prior,data);
% Evaluate the log-likelihood of m
logL=sippi_likelihood(data,d);
</screen>
</sect1>
